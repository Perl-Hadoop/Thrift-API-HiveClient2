#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package Thrift::API::HiveClient2::TProtocolVersion;
use constant HIVE_CLI_SERVICE_PROTOCOL_V1 => 0;
package Thrift::API::HiveClient2::TType;
use constant BOOLEAN_TYPE => 0;
use constant TINYINT_TYPE => 1;
use constant SMALLINT_TYPE => 2;
use constant INT_TYPE => 3;
use constant BIGINT_TYPE => 4;
use constant FLOAT_TYPE => 5;
use constant DOUBLE_TYPE => 6;
use constant STRING_TYPE => 7;
use constant TIMESTAMP_TYPE => 8;
use constant BINARY_TYPE => 9;
use constant ARRAY_TYPE => 10;
use constant MAP_TYPE => 11;
use constant STRUCT_TYPE => 12;
use constant UNION_TYPE => 13;
use constant USER_DEFINED_TYPE => 14;
package Thrift::API::HiveClient2::TStatusCode;
use constant SUCCESS_STATUS => 0;
use constant SUCCESS_WITH_INFO_STATUS => 1;
use constant STILL_EXECUTING_STATUS => 2;
use constant ERROR_STATUS => 3;
use constant INVALID_HANDLE_STATUS => 4;
package Thrift::API::HiveClient2::TOperationState;
use constant INITIALIZED_STATE => 0;
use constant RUNNING_STATE => 1;
use constant FINISHED_STATE => 2;
use constant CANCELED_STATE => 3;
use constant CLOSED_STATE => 4;
use constant ERROR_STATE => 5;
use constant UKNOWN_STATE => 6;
package Thrift::API::HiveClient2::TOperationType;
use constant EXECUTE_STATEMENT => 0;
use constant GET_TYPE_INFO => 1;
use constant GET_CATALOGS => 2;
use constant GET_SCHEMAS => 3;
use constant GET_TABLES => 4;
use constant GET_TABLE_TYPES => 5;
use constant GET_COLUMNS => 6;
use constant GET_FUNCTIONS => 7;
use constant UNKNOWN => 8;
package Thrift::API::HiveClient2::TGetInfoType;
use constant CLI_MAX_DRIVER_CONNECTIONS => 0;
use constant CLI_MAX_CONCURRENT_ACTIVITIES => 1;
use constant CLI_DATA_SOURCE_NAME => 2;
use constant CLI_FETCH_DIRECTION => 8;
use constant CLI_SERVER_NAME => 13;
use constant CLI_SEARCH_PATTERN_ESCAPE => 14;
use constant CLI_DBMS_NAME => 17;
use constant CLI_DBMS_VER => 18;
use constant CLI_ACCESSIBLE_TABLES => 19;
use constant CLI_ACCESSIBLE_PROCEDURES => 20;
use constant CLI_CURSOR_COMMIT_BEHAVIOR => 23;
use constant CLI_DATA_SOURCE_READ_ONLY => 25;
use constant CLI_DEFAULT_TXN_ISOLATION => 26;
use constant CLI_IDENTIFIER_CASE => 28;
use constant CLI_IDENTIFIER_QUOTE_CHAR => 29;
use constant CLI_MAX_COLUMN_NAME_LEN => 30;
use constant CLI_MAX_CURSOR_NAME_LEN => 31;
use constant CLI_MAX_SCHEMA_NAME_LEN => 32;
use constant CLI_MAX_CATALOG_NAME_LEN => 34;
use constant CLI_MAX_TABLE_NAME_LEN => 35;
use constant CLI_SCROLL_CONCURRENCY => 43;
use constant CLI_TXN_CAPABLE => 46;
use constant CLI_USER_NAME => 47;
use constant CLI_TXN_ISOLATION_OPTION => 72;
use constant CLI_INTEGRITY => 73;
use constant CLI_GETDATA_EXTENSIONS => 81;
use constant CLI_NULL_COLLATION => 85;
use constant CLI_ALTER_TABLE => 86;
use constant CLI_ORDER_BY_COLUMNS_IN_SELECT => 90;
use constant CLI_SPECIAL_CHARACTERS => 94;
use constant CLI_MAX_COLUMNS_IN_GROUP_BY => 97;
use constant CLI_MAX_COLUMNS_IN_INDEX => 98;
use constant CLI_MAX_COLUMNS_IN_ORDER_BY => 99;
use constant CLI_MAX_COLUMNS_IN_SELECT => 100;
use constant CLI_MAX_COLUMNS_IN_TABLE => 101;
use constant CLI_MAX_INDEX_SIZE => 102;
use constant CLI_MAX_ROW_SIZE => 104;
use constant CLI_MAX_STATEMENT_LEN => 105;
use constant CLI_MAX_TABLES_IN_SELECT => 106;
use constant CLI_MAX_USER_NAME_LEN => 107;
use constant CLI_OJ_CAPABILITIES => 115;
use constant CLI_XOPEN_CLI_YEAR => 10000;
use constant CLI_CURSOR_SENSITIVITY => 10001;
use constant CLI_DESCRIBE_PARAMETER => 10002;
use constant CLI_CATALOG_NAME => 10003;
use constant CLI_COLLATION_SEQ => 10004;
use constant CLI_MAX_IDENTIFIER_LEN => 10005;
package Thrift::API::HiveClient2::TFetchOrientation;
use constant FETCH_NEXT => 0;
use constant FETCH_PRIOR => 1;
use constant FETCH_RELATIVE => 2;
use constant FETCH_ABSOLUTE => 3;
use constant FETCH_FIRST => 4;
use constant FETCH_LAST => 5;
package Thrift::API::HiveClient2::TPrimitiveTypeEntry;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TPrimitiveTypeEntry->mk_accessors( qw( type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TPrimitiveTypeEntry';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TPrimitiveTypeEntry');
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::I32, 1);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TArrayTypeEntry;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TArrayTypeEntry->mk_accessors( qw( objectTypePtr ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{objectTypePtr} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{objectTypePtr}) {
      $self->{objectTypePtr} = $vals->{objectTypePtr};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TArrayTypeEntry';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{objectTypePtr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TArrayTypeEntry');
  if (defined $self->{objectTypePtr}) {
    $xfer += $output->writeFieldBegin('objectTypePtr', TType::I32, 1);
    $xfer += $output->writeI32($self->{objectTypePtr});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TMapTypeEntry;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TMapTypeEntry->mk_accessors( qw( keyTypePtr valueTypePtr ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyTypePtr} = undef;
  $self->{valueTypePtr} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyTypePtr}) {
      $self->{keyTypePtr} = $vals->{keyTypePtr};
    }
    if (defined $vals->{valueTypePtr}) {
      $self->{valueTypePtr} = $vals->{valueTypePtr};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TMapTypeEntry';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{keyTypePtr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{valueTypePtr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TMapTypeEntry');
  if (defined $self->{keyTypePtr}) {
    $xfer += $output->writeFieldBegin('keyTypePtr', TType::I32, 1);
    $xfer += $output->writeI32($self->{keyTypePtr});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{valueTypePtr}) {
    $xfer += $output->writeFieldBegin('valueTypePtr', TType::I32, 2);
    $xfer += $output->writeI32($self->{valueTypePtr});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TStructTypeEntry;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TStructTypeEntry->mk_accessors( qw( nameToTypePtr ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{nameToTypePtr} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{nameToTypePtr}) {
      $self->{nameToTypePtr} = $vals->{nameToTypePtr};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TStructTypeEntry';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size0 = 0;
          $self->{nameToTypePtr} = {};
          my $_ktype1 = 0;
          my $_vtype2 = 0;
          $xfer += $input->readMapBegin(\$_ktype1, \$_vtype2, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $key5 = '';
            my $val6 = 0;
            $xfer += $input->readString(\$key5);
            $xfer += $input->readI32(\$val6);
            $self->{nameToTypePtr}->{$key5} = $val6;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TStructTypeEntry');
  if (defined $self->{nameToTypePtr}) {
    $xfer += $output->writeFieldBegin('nameToTypePtr', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I32, scalar(keys %{$self->{nameToTypePtr}}));
      {
        while( my ($kiter7,$viter8) = each %{$self->{nameToTypePtr}}) 
        {
          $xfer += $output->writeString($kiter7);
          $xfer += $output->writeI32($viter8);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TUnionTypeEntry;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TUnionTypeEntry->mk_accessors( qw( nameToTypePtr ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{nameToTypePtr} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{nameToTypePtr}) {
      $self->{nameToTypePtr} = $vals->{nameToTypePtr};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TUnionTypeEntry';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size9 = 0;
          $self->{nameToTypePtr} = {};
          my $_ktype10 = 0;
          my $_vtype11 = 0;
          $xfer += $input->readMapBegin(\$_ktype10, \$_vtype11, \$_size9);
          for (my $_i13 = 0; $_i13 < $_size9; ++$_i13)
          {
            my $key14 = '';
            my $val15 = 0;
            $xfer += $input->readString(\$key14);
            $xfer += $input->readI32(\$val15);
            $self->{nameToTypePtr}->{$key14} = $val15;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TUnionTypeEntry');
  if (defined $self->{nameToTypePtr}) {
    $xfer += $output->writeFieldBegin('nameToTypePtr', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I32, scalar(keys %{$self->{nameToTypePtr}}));
      {
        while( my ($kiter16,$viter17) = each %{$self->{nameToTypePtr}}) 
        {
          $xfer += $output->writeString($kiter16);
          $xfer += $output->writeI32($viter17);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TUserDefinedTypeEntry;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TUserDefinedTypeEntry->mk_accessors( qw( typeClassName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{typeClassName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{typeClassName}) {
      $self->{typeClassName} = $vals->{typeClassName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TUserDefinedTypeEntry';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{typeClassName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TUserDefinedTypeEntry');
  if (defined $self->{typeClassName}) {
    $xfer += $output->writeFieldBegin('typeClassName', TType::STRING, 1);
    $xfer += $output->writeString($self->{typeClassName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TTypeEntry;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TTypeEntry->mk_accessors( qw( primitiveEntry arrayEntry mapEntry structEntry unionEntry userDefinedTypeEntry ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{primitiveEntry} = undef;
  $self->{arrayEntry} = undef;
  $self->{mapEntry} = undef;
  $self->{structEntry} = undef;
  $self->{unionEntry} = undef;
  $self->{userDefinedTypeEntry} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{primitiveEntry}) {
      $self->{primitiveEntry} = $vals->{primitiveEntry};
    }
    if (defined $vals->{arrayEntry}) {
      $self->{arrayEntry} = $vals->{arrayEntry};
    }
    if (defined $vals->{mapEntry}) {
      $self->{mapEntry} = $vals->{mapEntry};
    }
    if (defined $vals->{structEntry}) {
      $self->{structEntry} = $vals->{structEntry};
    }
    if (defined $vals->{unionEntry}) {
      $self->{unionEntry} = $vals->{unionEntry};
    }
    if (defined $vals->{userDefinedTypeEntry}) {
      $self->{userDefinedTypeEntry} = $vals->{userDefinedTypeEntry};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TTypeEntry';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{primitiveEntry} = new Thrift::API::HiveClient2::TPrimitiveTypeEntry();
        $xfer += $self->{primitiveEntry}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{arrayEntry} = new Thrift::API::HiveClient2::TArrayTypeEntry();
        $xfer += $self->{arrayEntry}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mapEntry} = new Thrift::API::HiveClient2::TMapTypeEntry();
        $xfer += $self->{mapEntry}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{structEntry} = new Thrift::API::HiveClient2::TStructTypeEntry();
        $xfer += $self->{structEntry}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{unionEntry} = new Thrift::API::HiveClient2::TUnionTypeEntry();
        $xfer += $self->{unionEntry}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{userDefinedTypeEntry} = new Thrift::API::HiveClient2::TUserDefinedTypeEntry();
        $xfer += $self->{userDefinedTypeEntry}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TTypeEntry');
  if (defined $self->{primitiveEntry}) {
    $xfer += $output->writeFieldBegin('primitiveEntry', TType::STRUCT, 1);
    $xfer += $self->{primitiveEntry}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arrayEntry}) {
    $xfer += $output->writeFieldBegin('arrayEntry', TType::STRUCT, 2);
    $xfer += $self->{arrayEntry}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mapEntry}) {
    $xfer += $output->writeFieldBegin('mapEntry', TType::STRUCT, 3);
    $xfer += $self->{mapEntry}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{structEntry}) {
    $xfer += $output->writeFieldBegin('structEntry', TType::STRUCT, 4);
    $xfer += $self->{structEntry}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{unionEntry}) {
    $xfer += $output->writeFieldBegin('unionEntry', TType::STRUCT, 5);
    $xfer += $self->{unionEntry}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userDefinedTypeEntry}) {
    $xfer += $output->writeFieldBegin('userDefinedTypeEntry', TType::STRUCT, 6);
    $xfer += $self->{userDefinedTypeEntry}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TTypeDesc;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TTypeDesc->mk_accessors( qw( types ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{types} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{types}) {
      $self->{types} = $vals->{types};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TTypeDesc';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size18 = 0;
          $self->{types} = [];
          my $_etype21 = 0;
          $xfer += $input->readListBegin(\$_etype21, \$_size18);
          for (my $_i22 = 0; $_i22 < $_size18; ++$_i22)
          {
            my $elem23 = undef;
            $elem23 = new Thrift::API::HiveClient2::TTypeEntry();
            $xfer += $elem23->read($input);
            push(@{$self->{types}},$elem23);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TTypeDesc');
  if (defined $self->{types}) {
    $xfer += $output->writeFieldBegin('types', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{types}}));
      {
        foreach my $iter24 (@{$self->{types}}) 
        {
          $xfer += ${iter24}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TColumnDesc;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TColumnDesc->mk_accessors( qw( columnName typeDesc position comment ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{columnName} = undef;
  $self->{typeDesc} = undef;
  $self->{position} = undef;
  $self->{comment} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{columnName}) {
      $self->{columnName} = $vals->{columnName};
    }
    if (defined $vals->{typeDesc}) {
      $self->{typeDesc} = $vals->{typeDesc};
    }
    if (defined $vals->{position}) {
      $self->{position} = $vals->{position};
    }
    if (defined $vals->{comment}) {
      $self->{comment} = $vals->{comment};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TColumnDesc';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{typeDesc} = new Thrift::API::HiveClient2::TTypeDesc();
        $xfer += $self->{typeDesc}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{position});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{comment});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TColumnDesc');
  if (defined $self->{columnName}) {
    $xfer += $output->writeFieldBegin('columnName', TType::STRING, 1);
    $xfer += $output->writeString($self->{columnName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{typeDesc}) {
    $xfer += $output->writeFieldBegin('typeDesc', TType::STRUCT, 2);
    $xfer += $self->{typeDesc}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{position}) {
    $xfer += $output->writeFieldBegin('position', TType::I32, 3);
    $xfer += $output->writeI32($self->{position});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{comment}) {
    $xfer += $output->writeFieldBegin('comment', TType::STRING, 4);
    $xfer += $output->writeString($self->{comment});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TTableSchema;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TTableSchema->mk_accessors( qw( columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TTableSchema';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size25 = 0;
          $self->{columns} = [];
          my $_etype28 = 0;
          $xfer += $input->readListBegin(\$_etype28, \$_size25);
          for (my $_i29 = 0; $_i29 < $_size25; ++$_i29)
          {
            my $elem30 = undef;
            $elem30 = new Thrift::API::HiveClient2::TColumnDesc();
            $xfer += $elem30->read($input);
            push(@{$self->{columns}},$elem30);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TTableSchema');
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter31 (@{$self->{columns}}) 
        {
          $xfer += ${iter31}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TBoolValue;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TBoolValue->mk_accessors( qw( value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TBoolValue';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TBoolValue');
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TByteValue;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TByteValue->mk_accessors( qw( value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TByteValue';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TByteValue');
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::BYTE, 1);
    $xfer += $output->writeByte($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TI16Value;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TI16Value->mk_accessors( qw( value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TI16Value';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TI16Value');
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::I16, 1);
    $xfer += $output->writeI16($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TI32Value;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TI32Value->mk_accessors( qw( value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TI32Value';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TI32Value');
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::I32, 1);
    $xfer += $output->writeI32($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TI64Value;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TI64Value->mk_accessors( qw( value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TI64Value';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TI64Value');
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::I64, 1);
    $xfer += $output->writeI64($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TDoubleValue;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TDoubleValue->mk_accessors( qw( value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TDoubleValue';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TDoubleValue');
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::DOUBLE, 1);
    $xfer += $output->writeDouble($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TStringValue;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TStringValue->mk_accessors( qw( value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TStringValue';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TStringValue');
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 1);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TColumn;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TColumn->mk_accessors( qw( boolColumn byteColumn i16Column i32Column i64Column doubleColumn stringColumn ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{boolColumn} = undef;
  $self->{byteColumn} = undef;
  $self->{i16Column} = undef;
  $self->{i32Column} = undef;
  $self->{i64Column} = undef;
  $self->{doubleColumn} = undef;
  $self->{stringColumn} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{boolColumn}) {
      $self->{boolColumn} = $vals->{boolColumn};
    }
    if (defined $vals->{byteColumn}) {
      $self->{byteColumn} = $vals->{byteColumn};
    }
    if (defined $vals->{i16Column}) {
      $self->{i16Column} = $vals->{i16Column};
    }
    if (defined $vals->{i32Column}) {
      $self->{i32Column} = $vals->{i32Column};
    }
    if (defined $vals->{i64Column}) {
      $self->{i64Column} = $vals->{i64Column};
    }
    if (defined $vals->{doubleColumn}) {
      $self->{doubleColumn} = $vals->{doubleColumn};
    }
    if (defined $vals->{stringColumn}) {
      $self->{stringColumn} = $vals->{stringColumn};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size32 = 0;
          $self->{boolColumn} = [];
          my $_etype35 = 0;
          $xfer += $input->readListBegin(\$_etype35, \$_size32);
          for (my $_i36 = 0; $_i36 < $_size32; ++$_i36)
          {
            my $elem37 = undef;
            $elem37 = new Thrift::API::HiveClient2::TBoolValue();
            $xfer += $elem37->read($input);
            push(@{$self->{boolColumn}},$elem37);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size38 = 0;
          $self->{byteColumn} = [];
          my $_etype41 = 0;
          $xfer += $input->readListBegin(\$_etype41, \$_size38);
          for (my $_i42 = 0; $_i42 < $_size38; ++$_i42)
          {
            my $elem43 = undef;
            $elem43 = new Thrift::API::HiveClient2::TByteValue();
            $xfer += $elem43->read($input);
            push(@{$self->{byteColumn}},$elem43);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size44 = 0;
          $self->{i16Column} = [];
          my $_etype47 = 0;
          $xfer += $input->readListBegin(\$_etype47, \$_size44);
          for (my $_i48 = 0; $_i48 < $_size44; ++$_i48)
          {
            my $elem49 = undef;
            $elem49 = new Thrift::API::HiveClient2::TI16Value();
            $xfer += $elem49->read($input);
            push(@{$self->{i16Column}},$elem49);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size50 = 0;
          $self->{i32Column} = [];
          my $_etype53 = 0;
          $xfer += $input->readListBegin(\$_etype53, \$_size50);
          for (my $_i54 = 0; $_i54 < $_size50; ++$_i54)
          {
            my $elem55 = undef;
            $elem55 = new Thrift::API::HiveClient2::TI32Value();
            $xfer += $elem55->read($input);
            push(@{$self->{i32Column}},$elem55);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size56 = 0;
          $self->{i64Column} = [];
          my $_etype59 = 0;
          $xfer += $input->readListBegin(\$_etype59, \$_size56);
          for (my $_i60 = 0; $_i60 < $_size56; ++$_i60)
          {
            my $elem61 = undef;
            $elem61 = new Thrift::API::HiveClient2::TI64Value();
            $xfer += $elem61->read($input);
            push(@{$self->{i64Column}},$elem61);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size62 = 0;
          $self->{doubleColumn} = [];
          my $_etype65 = 0;
          $xfer += $input->readListBegin(\$_etype65, \$_size62);
          for (my $_i66 = 0; $_i66 < $_size62; ++$_i66)
          {
            my $elem67 = undef;
            $elem67 = new Thrift::API::HiveClient2::TDoubleValue();
            $xfer += $elem67->read($input);
            push(@{$self->{doubleColumn}},$elem67);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size68 = 0;
          $self->{stringColumn} = [];
          my $_etype71 = 0;
          $xfer += $input->readListBegin(\$_etype71, \$_size68);
          for (my $_i72 = 0; $_i72 < $_size68; ++$_i72)
          {
            my $elem73 = undef;
            $elem73 = new Thrift::API::HiveClient2::TStringValue();
            $xfer += $elem73->read($input);
            push(@{$self->{stringColumn}},$elem73);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TColumn');
  if (defined $self->{boolColumn}) {
    $xfer += $output->writeFieldBegin('boolColumn', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{boolColumn}}));
      {
        foreach my $iter74 (@{$self->{boolColumn}}) 
        {
          $xfer += ${iter74}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{byteColumn}) {
    $xfer += $output->writeFieldBegin('byteColumn', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{byteColumn}}));
      {
        foreach my $iter75 (@{$self->{byteColumn}}) 
        {
          $xfer += ${iter75}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i16Column}) {
    $xfer += $output->writeFieldBegin('i16Column', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{i16Column}}));
      {
        foreach my $iter76 (@{$self->{i16Column}}) 
        {
          $xfer += ${iter76}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i32Column}) {
    $xfer += $output->writeFieldBegin('i32Column', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{i32Column}}));
      {
        foreach my $iter77 (@{$self->{i32Column}}) 
        {
          $xfer += ${iter77}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i64Column}) {
    $xfer += $output->writeFieldBegin('i64Column', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{i64Column}}));
      {
        foreach my $iter78 (@{$self->{i64Column}}) 
        {
          $xfer += ${iter78}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{doubleColumn}) {
    $xfer += $output->writeFieldBegin('doubleColumn', TType::LIST, 6);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{doubleColumn}}));
      {
        foreach my $iter79 (@{$self->{doubleColumn}}) 
        {
          $xfer += ${iter79}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stringColumn}) {
    $xfer += $output->writeFieldBegin('stringColumn', TType::LIST, 7);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{stringColumn}}));
      {
        foreach my $iter80 (@{$self->{stringColumn}}) 
        {
          $xfer += ${iter80}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TColumnValue;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TColumnValue->mk_accessors( qw( boolVal byteVal i16Val i32Val i64Val doubleVal stringVal ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{boolVal} = undef;
  $self->{byteVal} = undef;
  $self->{i16Val} = undef;
  $self->{i32Val} = undef;
  $self->{i64Val} = undef;
  $self->{doubleVal} = undef;
  $self->{stringVal} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{boolVal}) {
      $self->{boolVal} = $vals->{boolVal};
    }
    if (defined $vals->{byteVal}) {
      $self->{byteVal} = $vals->{byteVal};
    }
    if (defined $vals->{i16Val}) {
      $self->{i16Val} = $vals->{i16Val};
    }
    if (defined $vals->{i32Val}) {
      $self->{i32Val} = $vals->{i32Val};
    }
    if (defined $vals->{i64Val}) {
      $self->{i64Val} = $vals->{i64Val};
    }
    if (defined $vals->{doubleVal}) {
      $self->{doubleVal} = $vals->{doubleVal};
    }
    if (defined $vals->{stringVal}) {
      $self->{stringVal} = $vals->{stringVal};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TColumnValue';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{boolVal} = new Thrift::API::HiveClient2::TBoolValue();
        $xfer += $self->{boolVal}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{byteVal} = new Thrift::API::HiveClient2::TByteValue();
        $xfer += $self->{byteVal}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{i16Val} = new Thrift::API::HiveClient2::TI16Value();
        $xfer += $self->{i16Val}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{i32Val} = new Thrift::API::HiveClient2::TI32Value();
        $xfer += $self->{i32Val}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{i64Val} = new Thrift::API::HiveClient2::TI64Value();
        $xfer += $self->{i64Val}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{doubleVal} = new Thrift::API::HiveClient2::TDoubleValue();
        $xfer += $self->{doubleVal}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{stringVal} = new Thrift::API::HiveClient2::TStringValue();
        $xfer += $self->{stringVal}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TColumnValue');
  if (defined $self->{boolVal}) {
    $xfer += $output->writeFieldBegin('boolVal', TType::STRUCT, 1);
    $xfer += $self->{boolVal}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{byteVal}) {
    $xfer += $output->writeFieldBegin('byteVal', TType::STRUCT, 2);
    $xfer += $self->{byteVal}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i16Val}) {
    $xfer += $output->writeFieldBegin('i16Val', TType::STRUCT, 3);
    $xfer += $self->{i16Val}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i32Val}) {
    $xfer += $output->writeFieldBegin('i32Val', TType::STRUCT, 4);
    $xfer += $self->{i32Val}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{i64Val}) {
    $xfer += $output->writeFieldBegin('i64Val', TType::STRUCT, 5);
    $xfer += $self->{i64Val}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{doubleVal}) {
    $xfer += $output->writeFieldBegin('doubleVal', TType::STRUCT, 6);
    $xfer += $self->{doubleVal}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stringVal}) {
    $xfer += $output->writeFieldBegin('stringVal', TType::STRUCT, 7);
    $xfer += $self->{stringVal}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TRow;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TRow->mk_accessors( qw( colVals ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{colVals} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{colVals}) {
      $self->{colVals} = $vals->{colVals};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TRow';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size81 = 0;
          $self->{colVals} = [];
          my $_etype84 = 0;
          $xfer += $input->readListBegin(\$_etype84, \$_size81);
          for (my $_i85 = 0; $_i85 < $_size81; ++$_i85)
          {
            my $elem86 = undef;
            $elem86 = new Thrift::API::HiveClient2::TColumnValue();
            $xfer += $elem86->read($input);
            push(@{$self->{colVals}},$elem86);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TRow');
  if (defined $self->{colVals}) {
    $xfer += $output->writeFieldBegin('colVals', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{colVals}}));
      {
        foreach my $iter87 (@{$self->{colVals}}) 
        {
          $xfer += ${iter87}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TRowSet;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TRowSet->mk_accessors( qw( startRowOffset rows columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{startRowOffset} = undef;
  $self->{rows} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{startRowOffset}) {
      $self->{startRowOffset} = $vals->{startRowOffset};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TRowSet';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{startRowOffset});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size88 = 0;
          $self->{rows} = [];
          my $_etype91 = 0;
          $xfer += $input->readListBegin(\$_etype91, \$_size88);
          for (my $_i92 = 0; $_i92 < $_size88; ++$_i92)
          {
            my $elem93 = undef;
            $elem93 = new Thrift::API::HiveClient2::TRow();
            $xfer += $elem93->read($input);
            push(@{$self->{rows}},$elem93);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size94 = 0;
          $self->{columns} = [];
          my $_etype97 = 0;
          $xfer += $input->readListBegin(\$_etype97, \$_size94);
          for (my $_i98 = 0; $_i98 < $_size94; ++$_i98)
          {
            my $elem99 = undef;
            $elem99 = new Thrift::API::HiveClient2::TColumn();
            $xfer += $elem99->read($input);
            push(@{$self->{columns}},$elem99);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TRowSet');
  if (defined $self->{startRowOffset}) {
    $xfer += $output->writeFieldBegin('startRowOffset', TType::I64, 1);
    $xfer += $output->writeI64($self->{startRowOffset});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{rows}}));
      {
        foreach my $iter100 (@{$self->{rows}}) 
        {
          $xfer += ${iter100}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter101 (@{$self->{columns}}) 
        {
          $xfer += ${iter101}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TStatus;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TStatus->mk_accessors( qw( statusCode infoMessages sqlState errorCode errorMessage ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{statusCode} = undef;
  $self->{infoMessages} = undef;
  $self->{sqlState} = undef;
  $self->{errorCode} = undef;
  $self->{errorMessage} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{statusCode}) {
      $self->{statusCode} = $vals->{statusCode};
    }
    if (defined $vals->{infoMessages}) {
      $self->{infoMessages} = $vals->{infoMessages};
    }
    if (defined $vals->{sqlState}) {
      $self->{sqlState} = $vals->{sqlState};
    }
    if (defined $vals->{errorCode}) {
      $self->{errorCode} = $vals->{errorCode};
    }
    if (defined $vals->{errorMessage}) {
      $self->{errorMessage} = $vals->{errorMessage};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TStatus';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{statusCode});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size102 = 0;
          $self->{infoMessages} = [];
          my $_etype105 = 0;
          $xfer += $input->readListBegin(\$_etype105, \$_size102);
          for (my $_i106 = 0; $_i106 < $_size102; ++$_i106)
          {
            my $elem107 = undef;
            $xfer += $input->readString(\$elem107);
            push(@{$self->{infoMessages}},$elem107);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{sqlState});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{errorCode});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{errorMessage});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TStatus');
  if (defined $self->{statusCode}) {
    $xfer += $output->writeFieldBegin('statusCode', TType::I32, 1);
    $xfer += $output->writeI32($self->{statusCode});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{infoMessages}) {
    $xfer += $output->writeFieldBegin('infoMessages', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{infoMessages}}));
      {
        foreach my $iter108 (@{$self->{infoMessages}}) 
        {
          $xfer += $output->writeString($iter108);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sqlState}) {
    $xfer += $output->writeFieldBegin('sqlState', TType::STRING, 3);
    $xfer += $output->writeString($self->{sqlState});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{errorCode}) {
    $xfer += $output->writeFieldBegin('errorCode', TType::I32, 4);
    $xfer += $output->writeI32($self->{errorCode});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{errorMessage}) {
    $xfer += $output->writeFieldBegin('errorMessage', TType::STRING, 5);
    $xfer += $output->writeString($self->{errorMessage});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::THandleIdentifier;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::THandleIdentifier->mk_accessors( qw( guid secret ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{guid} = undef;
  $self->{secret} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
    if (defined $vals->{secret}) {
      $self->{secret} = $vals->{secret};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THandleIdentifier';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{secret});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THandleIdentifier');
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 1);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{secret}) {
    $xfer += $output->writeFieldBegin('secret', TType::STRING, 2);
    $xfer += $output->writeString($self->{secret});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TSessionHandle;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TSessionHandle->mk_accessors( qw( sessionId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sessionId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sessionId}) {
      $self->{sessionId} = $vals->{sessionId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TSessionHandle';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sessionId} = new Thrift::API::HiveClient2::THandleIdentifier();
        $xfer += $self->{sessionId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TSessionHandle');
  if (defined $self->{sessionId}) {
    $xfer += $output->writeFieldBegin('sessionId', TType::STRUCT, 1);
    $xfer += $self->{sessionId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TOperationHandle;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TOperationHandle->mk_accessors( qw( operationId operationType hasResultSet modifiedRowCount ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{operationId} = undef;
  $self->{operationType} = undef;
  $self->{hasResultSet} = undef;
  $self->{modifiedRowCount} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{operationId}) {
      $self->{operationId} = $vals->{operationId};
    }
    if (defined $vals->{operationType}) {
      $self->{operationType} = $vals->{operationType};
    }
    if (defined $vals->{hasResultSet}) {
      $self->{hasResultSet} = $vals->{hasResultSet};
    }
    if (defined $vals->{modifiedRowCount}) {
      $self->{modifiedRowCount} = $vals->{modifiedRowCount};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TOperationHandle';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{operationId} = new Thrift::API::HiveClient2::THandleIdentifier();
        $xfer += $self->{operationId}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{operationType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{hasResultSet});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{modifiedRowCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TOperationHandle');
  if (defined $self->{operationId}) {
    $xfer += $output->writeFieldBegin('operationId', TType::STRUCT, 1);
    $xfer += $self->{operationId}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{operationType}) {
    $xfer += $output->writeFieldBegin('operationType', TType::I32, 2);
    $xfer += $output->writeI32($self->{operationType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{hasResultSet}) {
    $xfer += $output->writeFieldBegin('hasResultSet', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{hasResultSet});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{modifiedRowCount}) {
    $xfer += $output->writeFieldBegin('modifiedRowCount', TType::DOUBLE, 4);
    $xfer += $output->writeDouble($self->{modifiedRowCount});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TOpenSessionReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TOpenSessionReq->mk_accessors( qw( client_protocol username password configuration ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{client_protocol} = 0;
  $self->{username} = undef;
  $self->{password} = undef;
  $self->{configuration} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{client_protocol}) {
      $self->{client_protocol} = $vals->{client_protocol};
    }
    if (defined $vals->{username}) {
      $self->{username} = $vals->{username};
    }
    if (defined $vals->{password}) {
      $self->{password} = $vals->{password};
    }
    if (defined $vals->{configuration}) {
      $self->{configuration} = $vals->{configuration};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TOpenSessionReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{client_protocol});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{username});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{password});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size109 = 0;
          $self->{configuration} = {};
          my $_ktype110 = 0;
          my $_vtype111 = 0;
          $xfer += $input->readMapBegin(\$_ktype110, \$_vtype111, \$_size109);
          for (my $_i113 = 0; $_i113 < $_size109; ++$_i113)
          {
            my $key114 = '';
            my $val115 = '';
            $xfer += $input->readString(\$key114);
            $xfer += $input->readString(\$val115);
            $self->{configuration}->{$key114} = $val115;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TOpenSessionReq');
  if (defined $self->{client_protocol}) {
    $xfer += $output->writeFieldBegin('client_protocol', TType::I32, 1);
    $xfer += $output->writeI32($self->{client_protocol});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{username}) {
    $xfer += $output->writeFieldBegin('username', TType::STRING, 2);
    $xfer += $output->writeString($self->{username});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{password}) {
    $xfer += $output->writeFieldBegin('password', TType::STRING, 3);
    $xfer += $output->writeString($self->{password});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{configuration}) {
    $xfer += $output->writeFieldBegin('configuration', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{configuration}}));
      {
        while( my ($kiter116,$viter117) = each %{$self->{configuration}}) 
        {
          $xfer += $output->writeString($kiter116);
          $xfer += $output->writeString($viter117);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TOpenSessionResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TOpenSessionResp->mk_accessors( qw( status serverProtocolVersion sessionHandle configuration ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  $self->{serverProtocolVersion} = 0;
  $self->{sessionHandle} = undef;
  $self->{configuration} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
    if (defined $vals->{serverProtocolVersion}) {
      $self->{serverProtocolVersion} = $vals->{serverProtocolVersion};
    }
    if (defined $vals->{sessionHandle}) {
      $self->{sessionHandle} = $vals->{sessionHandle};
    }
    if (defined $vals->{configuration}) {
      $self->{configuration} = $vals->{configuration};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TOpenSessionResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{serverProtocolVersion});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sessionHandle} = new Thrift::API::HiveClient2::TSessionHandle();
        $xfer += $self->{sessionHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size118 = 0;
          $self->{configuration} = {};
          my $_ktype119 = 0;
          my $_vtype120 = 0;
          $xfer += $input->readMapBegin(\$_ktype119, \$_vtype120, \$_size118);
          for (my $_i122 = 0; $_i122 < $_size118; ++$_i122)
          {
            my $key123 = '';
            my $val124 = '';
            $xfer += $input->readString(\$key123);
            $xfer += $input->readString(\$val124);
            $self->{configuration}->{$key123} = $val124;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TOpenSessionResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{serverProtocolVersion}) {
    $xfer += $output->writeFieldBegin('serverProtocolVersion', TType::I32, 2);
    $xfer += $output->writeI32($self->{serverProtocolVersion});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sessionHandle}) {
    $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 3);
    $xfer += $self->{sessionHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{configuration}) {
    $xfer += $output->writeFieldBegin('configuration', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{configuration}}));
      {
        while( my ($kiter125,$viter126) = each %{$self->{configuration}}) 
        {
          $xfer += $output->writeString($kiter125);
          $xfer += $output->writeString($viter126);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TCloseSessionReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TCloseSessionReq->mk_accessors( qw( sessionHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sessionHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sessionHandle}) {
      $self->{sessionHandle} = $vals->{sessionHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TCloseSessionReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sessionHandle} = new Thrift::API::HiveClient2::TSessionHandle();
        $xfer += $self->{sessionHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TCloseSessionReq');
  if (defined $self->{sessionHandle}) {
    $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
    $xfer += $self->{sessionHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TCloseSessionResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TCloseSessionResp->mk_accessors( qw( status ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TCloseSessionResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TCloseSessionResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetInfoValue;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetInfoValue->mk_accessors( qw( stringValue smallIntValue integerBitmask integerFlag binaryValue lenValue ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{stringValue} = undef;
  $self->{smallIntValue} = undef;
  $self->{integerBitmask} = undef;
  $self->{integerFlag} = undef;
  $self->{binaryValue} = undef;
  $self->{lenValue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{stringValue}) {
      $self->{stringValue} = $vals->{stringValue};
    }
    if (defined $vals->{smallIntValue}) {
      $self->{smallIntValue} = $vals->{smallIntValue};
    }
    if (defined $vals->{integerBitmask}) {
      $self->{integerBitmask} = $vals->{integerBitmask};
    }
    if (defined $vals->{integerFlag}) {
      $self->{integerFlag} = $vals->{integerFlag};
    }
    if (defined $vals->{binaryValue}) {
      $self->{binaryValue} = $vals->{binaryValue};
    }
    if (defined $vals->{lenValue}) {
      $self->{lenValue} = $vals->{lenValue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetInfoValue';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stringValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{smallIntValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{integerBitmask});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{integerFlag});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{binaryValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{lenValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetInfoValue');
  if (defined $self->{stringValue}) {
    $xfer += $output->writeFieldBegin('stringValue', TType::STRING, 1);
    $xfer += $output->writeString($self->{stringValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{smallIntValue}) {
    $xfer += $output->writeFieldBegin('smallIntValue', TType::I16, 2);
    $xfer += $output->writeI16($self->{smallIntValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{integerBitmask}) {
    $xfer += $output->writeFieldBegin('integerBitmask', TType::I32, 3);
    $xfer += $output->writeI32($self->{integerBitmask});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{integerFlag}) {
    $xfer += $output->writeFieldBegin('integerFlag', TType::I32, 4);
    $xfer += $output->writeI32($self->{integerFlag});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{binaryValue}) {
    $xfer += $output->writeFieldBegin('binaryValue', TType::I32, 5);
    $xfer += $output->writeI32($self->{binaryValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{lenValue}) {
    $xfer += $output->writeFieldBegin('lenValue', TType::I64, 6);
    $xfer += $output->writeI64($self->{lenValue});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetInfoReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetInfoReq->mk_accessors( qw( sessionHandle infoType ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sessionHandle} = undef;
  $self->{infoType} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sessionHandle}) {
      $self->{sessionHandle} = $vals->{sessionHandle};
    }
    if (defined $vals->{infoType}) {
      $self->{infoType} = $vals->{infoType};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetInfoReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sessionHandle} = new Thrift::API::HiveClient2::TSessionHandle();
        $xfer += $self->{sessionHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{infoType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetInfoReq');
  if (defined $self->{sessionHandle}) {
    $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
    $xfer += $self->{sessionHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{infoType}) {
    $xfer += $output->writeFieldBegin('infoType', TType::I32, 2);
    $xfer += $output->writeI32($self->{infoType});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetInfoResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetInfoResp->mk_accessors( qw( status infoValue ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  $self->{infoValue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
    if (defined $vals->{infoValue}) {
      $self->{infoValue} = $vals->{infoValue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetInfoResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{infoValue} = new Thrift::API::HiveClient2::TGetInfoValue();
        $xfer += $self->{infoValue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetInfoResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{infoValue}) {
    $xfer += $output->writeFieldBegin('infoValue', TType::STRUCT, 2);
    $xfer += $self->{infoValue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TExecuteStatementReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TExecuteStatementReq->mk_accessors( qw( sessionHandle statement confOverlay ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sessionHandle} = undef;
  $self->{statement} = undef;
  $self->{confOverlay} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sessionHandle}) {
      $self->{sessionHandle} = $vals->{sessionHandle};
    }
    if (defined $vals->{statement}) {
      $self->{statement} = $vals->{statement};
    }
    if (defined $vals->{confOverlay}) {
      $self->{confOverlay} = $vals->{confOverlay};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TExecuteStatementReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sessionHandle} = new Thrift::API::HiveClient2::TSessionHandle();
        $xfer += $self->{sessionHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{statement});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size127 = 0;
          $self->{confOverlay} = {};
          my $_ktype128 = 0;
          my $_vtype129 = 0;
          $xfer += $input->readMapBegin(\$_ktype128, \$_vtype129, \$_size127);
          for (my $_i131 = 0; $_i131 < $_size127; ++$_i131)
          {
            my $key132 = '';
            my $val133 = '';
            $xfer += $input->readString(\$key132);
            $xfer += $input->readString(\$val133);
            $self->{confOverlay}->{$key132} = $val133;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TExecuteStatementReq');
  if (defined $self->{sessionHandle}) {
    $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
    $xfer += $self->{sessionHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{statement}) {
    $xfer += $output->writeFieldBegin('statement', TType::STRING, 2);
    $xfer += $output->writeString($self->{statement});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{confOverlay}) {
    $xfer += $output->writeFieldBegin('confOverlay', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{confOverlay}}));
      {
        while( my ($kiter134,$viter135) = each %{$self->{confOverlay}}) 
        {
          $xfer += $output->writeString($kiter134);
          $xfer += $output->writeString($viter135);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TExecuteStatementResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TExecuteStatementResp->mk_accessors( qw( status operationHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  $self->{operationHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
    if (defined $vals->{operationHandle}) {
      $self->{operationHandle} = $vals->{operationHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TExecuteStatementResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{operationHandle} = new Thrift::API::HiveClient2::TOperationHandle();
        $xfer += $self->{operationHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TExecuteStatementResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{operationHandle}) {
    $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
    $xfer += $self->{operationHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetTypeInfoReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetTypeInfoReq->mk_accessors( qw( sessionHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sessionHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sessionHandle}) {
      $self->{sessionHandle} = $vals->{sessionHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetTypeInfoReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sessionHandle} = new Thrift::API::HiveClient2::TSessionHandle();
        $xfer += $self->{sessionHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetTypeInfoReq');
  if (defined $self->{sessionHandle}) {
    $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
    $xfer += $self->{sessionHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetTypeInfoResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetTypeInfoResp->mk_accessors( qw( status operationHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  $self->{operationHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
    if (defined $vals->{operationHandle}) {
      $self->{operationHandle} = $vals->{operationHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetTypeInfoResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{operationHandle} = new Thrift::API::HiveClient2::TOperationHandle();
        $xfer += $self->{operationHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetTypeInfoResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{operationHandle}) {
    $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
    $xfer += $self->{operationHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetCatalogsReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetCatalogsReq->mk_accessors( qw( sessionHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sessionHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sessionHandle}) {
      $self->{sessionHandle} = $vals->{sessionHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetCatalogsReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sessionHandle} = new Thrift::API::HiveClient2::TSessionHandle();
        $xfer += $self->{sessionHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetCatalogsReq');
  if (defined $self->{sessionHandle}) {
    $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
    $xfer += $self->{sessionHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetCatalogsResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetCatalogsResp->mk_accessors( qw( status operationHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  $self->{operationHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
    if (defined $vals->{operationHandle}) {
      $self->{operationHandle} = $vals->{operationHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetCatalogsResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{operationHandle} = new Thrift::API::HiveClient2::TOperationHandle();
        $xfer += $self->{operationHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetCatalogsResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{operationHandle}) {
    $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
    $xfer += $self->{operationHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetSchemasReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetSchemasReq->mk_accessors( qw( sessionHandle catalogName schemaName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sessionHandle} = undef;
  $self->{catalogName} = undef;
  $self->{schemaName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sessionHandle}) {
      $self->{sessionHandle} = $vals->{sessionHandle};
    }
    if (defined $vals->{catalogName}) {
      $self->{catalogName} = $vals->{catalogName};
    }
    if (defined $vals->{schemaName}) {
      $self->{schemaName} = $vals->{schemaName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetSchemasReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sessionHandle} = new Thrift::API::HiveClient2::TSessionHandle();
        $xfer += $self->{sessionHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{catalogName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{schemaName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetSchemasReq');
  if (defined $self->{sessionHandle}) {
    $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
    $xfer += $self->{sessionHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{catalogName}) {
    $xfer += $output->writeFieldBegin('catalogName', TType::STRING, 2);
    $xfer += $output->writeString($self->{catalogName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schemaName}) {
    $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 3);
    $xfer += $output->writeString($self->{schemaName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetSchemasResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetSchemasResp->mk_accessors( qw( status operationHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  $self->{operationHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
    if (defined $vals->{operationHandle}) {
      $self->{operationHandle} = $vals->{operationHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetSchemasResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{operationHandle} = new Thrift::API::HiveClient2::TOperationHandle();
        $xfer += $self->{operationHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetSchemasResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{operationHandle}) {
    $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
    $xfer += $self->{operationHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetTablesReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetTablesReq->mk_accessors( qw( sessionHandle catalogName schemaName tableName tableTypes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sessionHandle} = undef;
  $self->{catalogName} = undef;
  $self->{schemaName} = undef;
  $self->{tableName} = undef;
  $self->{tableTypes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sessionHandle}) {
      $self->{sessionHandle} = $vals->{sessionHandle};
    }
    if (defined $vals->{catalogName}) {
      $self->{catalogName} = $vals->{catalogName};
    }
    if (defined $vals->{schemaName}) {
      $self->{schemaName} = $vals->{schemaName};
    }
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{tableTypes}) {
      $self->{tableTypes} = $vals->{tableTypes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetTablesReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sessionHandle} = new Thrift::API::HiveClient2::TSessionHandle();
        $xfer += $self->{sessionHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{catalogName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{schemaName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size136 = 0;
          $self->{tableTypes} = [];
          my $_etype139 = 0;
          $xfer += $input->readListBegin(\$_etype139, \$_size136);
          for (my $_i140 = 0; $_i140 < $_size136; ++$_i140)
          {
            my $elem141 = undef;
            $xfer += $input->readString(\$elem141);
            push(@{$self->{tableTypes}},$elem141);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetTablesReq');
  if (defined $self->{sessionHandle}) {
    $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
    $xfer += $self->{sessionHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{catalogName}) {
    $xfer += $output->writeFieldBegin('catalogName', TType::STRING, 2);
    $xfer += $output->writeString($self->{catalogName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schemaName}) {
    $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 3);
    $xfer += $output->writeString($self->{schemaName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 4);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableTypes}) {
    $xfer += $output->writeFieldBegin('tableTypes', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{tableTypes}}));
      {
        foreach my $iter142 (@{$self->{tableTypes}}) 
        {
          $xfer += $output->writeString($iter142);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetTablesResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetTablesResp->mk_accessors( qw( status operationHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  $self->{operationHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
    if (defined $vals->{operationHandle}) {
      $self->{operationHandle} = $vals->{operationHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetTablesResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{operationHandle} = new Thrift::API::HiveClient2::TOperationHandle();
        $xfer += $self->{operationHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetTablesResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{operationHandle}) {
    $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
    $xfer += $self->{operationHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetTableTypesReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetTableTypesReq->mk_accessors( qw( sessionHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sessionHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sessionHandle}) {
      $self->{sessionHandle} = $vals->{sessionHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetTableTypesReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sessionHandle} = new Thrift::API::HiveClient2::TSessionHandle();
        $xfer += $self->{sessionHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetTableTypesReq');
  if (defined $self->{sessionHandle}) {
    $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
    $xfer += $self->{sessionHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetTableTypesResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetTableTypesResp->mk_accessors( qw( status operationHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  $self->{operationHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
    if (defined $vals->{operationHandle}) {
      $self->{operationHandle} = $vals->{operationHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetTableTypesResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{operationHandle} = new Thrift::API::HiveClient2::TOperationHandle();
        $xfer += $self->{operationHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetTableTypesResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{operationHandle}) {
    $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
    $xfer += $self->{operationHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetColumnsReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetColumnsReq->mk_accessors( qw( sessionHandle catalogName schemaName tableName columnName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sessionHandle} = undef;
  $self->{catalogName} = undef;
  $self->{schemaName} = undef;
  $self->{tableName} = undef;
  $self->{columnName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sessionHandle}) {
      $self->{sessionHandle} = $vals->{sessionHandle};
    }
    if (defined $vals->{catalogName}) {
      $self->{catalogName} = $vals->{catalogName};
    }
    if (defined $vals->{schemaName}) {
      $self->{schemaName} = $vals->{schemaName};
    }
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{columnName}) {
      $self->{columnName} = $vals->{columnName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetColumnsReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sessionHandle} = new Thrift::API::HiveClient2::TSessionHandle();
        $xfer += $self->{sessionHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{catalogName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{schemaName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetColumnsReq');
  if (defined $self->{sessionHandle}) {
    $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
    $xfer += $self->{sessionHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{catalogName}) {
    $xfer += $output->writeFieldBegin('catalogName', TType::STRING, 2);
    $xfer += $output->writeString($self->{catalogName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schemaName}) {
    $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 3);
    $xfer += $output->writeString($self->{schemaName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 4);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnName}) {
    $xfer += $output->writeFieldBegin('columnName', TType::STRING, 5);
    $xfer += $output->writeString($self->{columnName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetColumnsResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetColumnsResp->mk_accessors( qw( status operationHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  $self->{operationHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
    if (defined $vals->{operationHandle}) {
      $self->{operationHandle} = $vals->{operationHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetColumnsResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{operationHandle} = new Thrift::API::HiveClient2::TOperationHandle();
        $xfer += $self->{operationHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetColumnsResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{operationHandle}) {
    $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
    $xfer += $self->{operationHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetFunctionsReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetFunctionsReq->mk_accessors( qw( sessionHandle catalogName schemaName functionName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sessionHandle} = undef;
  $self->{catalogName} = undef;
  $self->{schemaName} = undef;
  $self->{functionName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sessionHandle}) {
      $self->{sessionHandle} = $vals->{sessionHandle};
    }
    if (defined $vals->{catalogName}) {
      $self->{catalogName} = $vals->{catalogName};
    }
    if (defined $vals->{schemaName}) {
      $self->{schemaName} = $vals->{schemaName};
    }
    if (defined $vals->{functionName}) {
      $self->{functionName} = $vals->{functionName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetFunctionsReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sessionHandle} = new Thrift::API::HiveClient2::TSessionHandle();
        $xfer += $self->{sessionHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{catalogName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{schemaName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{functionName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetFunctionsReq');
  if (defined $self->{sessionHandle}) {
    $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
    $xfer += $self->{sessionHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{catalogName}) {
    $xfer += $output->writeFieldBegin('catalogName', TType::STRING, 2);
    $xfer += $output->writeString($self->{catalogName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schemaName}) {
    $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 3);
    $xfer += $output->writeString($self->{schemaName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{functionName}) {
    $xfer += $output->writeFieldBegin('functionName', TType::STRING, 4);
    $xfer += $output->writeString($self->{functionName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetFunctionsResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetFunctionsResp->mk_accessors( qw( status operationHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  $self->{operationHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
    if (defined $vals->{operationHandle}) {
      $self->{operationHandle} = $vals->{operationHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetFunctionsResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{operationHandle} = new Thrift::API::HiveClient2::TOperationHandle();
        $xfer += $self->{operationHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetFunctionsResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{operationHandle}) {
    $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
    $xfer += $self->{operationHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetOperationStatusReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetOperationStatusReq->mk_accessors( qw( operationHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{operationHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{operationHandle}) {
      $self->{operationHandle} = $vals->{operationHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetOperationStatusReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{operationHandle} = new Thrift::API::HiveClient2::TOperationHandle();
        $xfer += $self->{operationHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetOperationStatusReq');
  if (defined $self->{operationHandle}) {
    $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
    $xfer += $self->{operationHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetOperationStatusResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetOperationStatusResp->mk_accessors( qw( status operationState ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  $self->{operationState} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
    if (defined $vals->{operationState}) {
      $self->{operationState} = $vals->{operationState};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetOperationStatusResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{operationState});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetOperationStatusResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{operationState}) {
    $xfer += $output->writeFieldBegin('operationState', TType::I32, 2);
    $xfer += $output->writeI32($self->{operationState});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TCancelOperationReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TCancelOperationReq->mk_accessors( qw( operationHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{operationHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{operationHandle}) {
      $self->{operationHandle} = $vals->{operationHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TCancelOperationReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{operationHandle} = new Thrift::API::HiveClient2::TOperationHandle();
        $xfer += $self->{operationHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TCancelOperationReq');
  if (defined $self->{operationHandle}) {
    $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
    $xfer += $self->{operationHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TCancelOperationResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TCancelOperationResp->mk_accessors( qw( status ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TCancelOperationResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TCancelOperationResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TCloseOperationReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TCloseOperationReq->mk_accessors( qw( operationHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{operationHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{operationHandle}) {
      $self->{operationHandle} = $vals->{operationHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TCloseOperationReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{operationHandle} = new Thrift::API::HiveClient2::TOperationHandle();
        $xfer += $self->{operationHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TCloseOperationReq');
  if (defined $self->{operationHandle}) {
    $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
    $xfer += $self->{operationHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TCloseOperationResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TCloseOperationResp->mk_accessors( qw( status ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TCloseOperationResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TCloseOperationResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetResultSetMetadataReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetResultSetMetadataReq->mk_accessors( qw( operationHandle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{operationHandle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{operationHandle}) {
      $self->{operationHandle} = $vals->{operationHandle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetResultSetMetadataReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{operationHandle} = new Thrift::API::HiveClient2::TOperationHandle();
        $xfer += $self->{operationHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetResultSetMetadataReq');
  if (defined $self->{operationHandle}) {
    $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
    $xfer += $self->{operationHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TGetResultSetMetadataResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TGetResultSetMetadataResp->mk_accessors( qw( status schema ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  $self->{schema} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGetResultSetMetadataResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{schema} = new Thrift::API::HiveClient2::TTableSchema();
        $xfer += $self->{schema}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGetResultSetMetadataResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', TType::STRUCT, 2);
    $xfer += $self->{schema}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TFetchResultsReq;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TFetchResultsReq->mk_accessors( qw( operationHandle orientation maxRows ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{operationHandle} = undef;
  $self->{orientation} = 0;
  $self->{maxRows} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{operationHandle}) {
      $self->{operationHandle} = $vals->{operationHandle};
    }
    if (defined $vals->{orientation}) {
      $self->{orientation} = $vals->{orientation};
    }
    if (defined $vals->{maxRows}) {
      $self->{maxRows} = $vals->{maxRows};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TFetchResultsReq';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{operationHandle} = new Thrift::API::HiveClient2::TOperationHandle();
        $xfer += $self->{operationHandle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{orientation});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{maxRows});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TFetchResultsReq');
  if (defined $self->{operationHandle}) {
    $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
    $xfer += $self->{operationHandle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{orientation}) {
    $xfer += $output->writeFieldBegin('orientation', TType::I32, 2);
    $xfer += $output->writeI32($self->{orientation});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxRows}) {
    $xfer += $output->writeFieldBegin('maxRows', TType::I64, 3);
    $xfer += $output->writeI64($self->{maxRows});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HiveClient2::TFetchResultsResp;
use base qw(Class::Accessor);
Thrift::API::HiveClient2::TFetchResultsResp->mk_accessors( qw( status hasMoreRows results ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = undef;
  $self->{hasMoreRows} = undef;
  $self->{results} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
    if (defined $vals->{hasMoreRows}) {
      $self->{hasMoreRows} = $vals->{hasMoreRows};
    }
    if (defined $vals->{results}) {
      $self->{results} = $vals->{results};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TFetchResultsResp';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{status} = new Thrift::API::HiveClient2::TStatus();
        $xfer += $self->{status}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{hasMoreRows});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{results} = new Thrift::API::HiveClient2::TRowSet();
        $xfer += $self->{results}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TFetchResultsResp');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
    $xfer += $self->{status}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{hasMoreRows}) {
    $xfer += $output->writeFieldBegin('hasMoreRows', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{hasMoreRows});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{results}) {
    $xfer += $output->writeFieldBegin('results', TType::STRUCT, 3);
    $xfer += $self->{results}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
